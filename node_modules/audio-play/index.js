/** @module  audio-play, play audio buffer in node */

'use strict'

var AudioSource = require('audio-source/direct')
var AudioSpeaker = require('audio-speaker/direct')
var isAudioBuffer = require('is-audio-buffer')
var AudioBuffer = require('audio-buffer')
var idx = require('negative-index')

module.exports = function Play (buffer, how, cb) {
	if (!isAudioBuffer(buffer)) throw Error('Argument should be an audio buffer')

	if (how instanceof Function) {
		cb = how
	}

	how = how || {}
	cb = cb || function () {}

	if (how.currentTime == null) how.currentTime = 0
	if (how.start == null) how.start = 0
	if (how.end == null) how.end = buffer.duration
	how.start = idx(how.start, buffer.duration)
	how.end = idx(how.end, buffer.duration)


	//prepare buffer - slice to duration
	if (how.start != 0 || how.end != buffer.duration) {
		var start = Math.floor(how.start * buffer.sampleRate)
		var end = Math.floor(how.end * buffer.sampleRate)
		var slicedBuffer = new AudioBuffer(null, {
			numberOfChannels: buffer.numberOfChannels,
			length: end - start,
			sampleRate: buffer.sampleRate
		})
		for (var channel = 0; channel < buffer.numberOfChannels; channel++) {
			slicedBuffer.getChannelData(channel).set(
				buffer.getChannelData(channel).subarray(start, end)
			)
		}
		buffer = slicedBuffer
	}

	//TODO: somewhere here goes rate mapping, volume and detune


	var read = AudioSource(buffer, {
		loop: how.loop
	}, function () {
		//node-speaker fix: we send 2s of silence
		write(new AudioBuffer(null, {
			length: buffer.sampleRate * 2,
			numberOfChannels: buffer.numberOfChannels,
			sampleRate: buffer.sampleRate
		}))
	})
	var write = AudioSpeaker({
		channels: buffer.numberOfChannels,
		sampleRate: buffer.sampleRate
	})

	//provide API
	play.play = pause.play = play
	play.pause = pause.pause = pause

	var isPlaying = false

	return how.autoplay != false ? play() : play

	function play () {
		if (isPlaying) return

		isPlaying = true

		;(function loop (err, buf) {
			if (err) {
				return cb(err)
			}
			if (!isPlaying) return

			buf = read(buf)

			if (!buf) {
				pause()
				return
			}

			//track current time
			how.currentTime += buf.duration
			play.currentTime = pause.currentTime = how.currentTime

			write(buf, loop)
		}())

		return pause
	}

	function pause () {
		if (!isPlaying) return
		isPlaying = false
		cb()

		return play
	}
}
